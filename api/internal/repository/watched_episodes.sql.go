// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: watched_episodes.sql

package repository

import (
	"context"
)

const getWatchedSeasons = `-- name: GetWatchedSeasons :many
SELECT s.id, s.tv_show_id, s.season_number, s.episode_count, s.air_date, s.created_at, s.last_fetched_at
FROM tv_shows_seasons s
JOIN tv_shows t ON s.tv_show_id = t.id
WHERE NOT EXISTS (
    SELECT 1
    FROM tv_shows_episodes e
    LEFT JOIN (
        SELECT DISTINCT episode_id
        FROM watched_episodes
        WHERE user_id = $1
    ) w ON e.id = w.episode_id
    WHERE e.season_id = s.id AND w.episode_id IS NULL
)
ORDER BY s.season_number
`

func (q *Queries) GetWatchedSeasons(ctx context.Context, userID int32) ([]TvShowsSeason, error) {
	rows, err := q.db.Query(ctx, getWatchedSeasons, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TvShowsSeason
	for rows.Next() {
		var i TvShowsSeason
		if err := rows.Scan(
			&i.ID,
			&i.TvShowID,
			&i.SeasonNumber,
			&i.EpisodeCount,
			&i.AirDate,
			&i.CreatedAt,
			&i.LastFetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedShows = `-- name: GetWatchedShows :many
SELECT DISTINCT t.id, t.tmdb_id, t.created_at, t.last_fetched_at, t.title, t.release_date, t.poster_url, t.overview, t.genres, t.vote_average, t.version
FROM watched_episodes w
JOIN tv_shows_episodes e ON w.episode_id = e.id
JOIN tv_shows t ON e.tv_show_id = t.id
WHERE w.user_id = $1
GROUP BY t.id
ORDER BY t.title
`

func (q *Queries) GetWatchedShows(ctx context.Context, userID int32) ([]TvShow, error) {
	rows, err := q.db.Query(ctx, getWatchedShows, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TvShow
	for rows.Next() {
		var i TvShow
		if err := rows.Scan(
			&i.ID,
			&i.TmdbID,
			&i.CreatedAt,
			&i.LastFetchedAt,
			&i.Title,
			&i.ReleaseDate,
			&i.PosterUrl,
			&i.Overview,
			&i.Genres,
			&i.VoteAverage,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWatchedEpisode = `-- name: InsertWatchedEpisode :one
INSERT INTO watched_episodes
(user_id, episode_id)
VALUES($1, $2)
RETURNING id, user_id, episode_id, watched_at
`

type InsertWatchedEpisodeParams struct {
	UserID    int32 `json:"user_id"`
	EpisodeID int32 `json:"episode_id"`
}

func (q *Queries) InsertWatchedEpisode(ctx context.Context, arg InsertWatchedEpisodeParams) (WatchedEpisode, error) {
	row := q.db.QueryRow(ctx, insertWatchedEpisode, arg.UserID, arg.EpisodeID)
	var i WatchedEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.WatchedAt,
	)
	return i, err
}

const insertWatchedSeason = `-- name: InsertWatchedSeason :one
INSERT INTO watched_episodes
(user_id, episode_id)
SELECT $1, id
FROM tv_shows_episodes
WHERE season_id = $2
ON CONFLICT DO NOTHING
RETURNING id, user_id, episode_id, watched_at
`

type InsertWatchedSeasonParams struct {
	UserID   int32 `json:"user_id"`
	SeasonID int64 `json:"season_id"`
}

func (q *Queries) InsertWatchedSeason(ctx context.Context, arg InsertWatchedSeasonParams) (WatchedEpisode, error) {
	row := q.db.QueryRow(ctx, insertWatchedSeason, arg.UserID, arg.SeasonID)
	var i WatchedEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.WatchedAt,
	)
	return i, err
}

const insertWatchedShow = `-- name: InsertWatchedShow :one
INSERT INTO watched_episodes
(user_id, episode_id)
SELECT $1, id
FROM tv_shows_episodes
WHERE tv_show_id = $2
ON CONFLICT DO NOTHING
RETURNING id, user_id, episode_id, watched_at
`

type InsertWatchedShowParams struct {
	UserID   int32 `json:"user_id"`
	TvShowID int64 `json:"tv_show_id"`
}

func (q *Queries) InsertWatchedShow(ctx context.Context, arg InsertWatchedShowParams) (WatchedEpisode, error) {
	row := q.db.QueryRow(ctx, insertWatchedShow, arg.UserID, arg.TvShowID)
	var i WatchedEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeID,
		&i.WatchedAt,
	)
	return i, err
}

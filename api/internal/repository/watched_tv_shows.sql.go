// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: watched_tv_shows.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWatchedTvEpisodes = `-- name: CountWatchedTvEpisodes :one
SELECT COUNT(*) FROM watched_tv_episodes WHERE user_id = $1
`

func (q *Queries) CountWatchedTvEpisodes(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countWatchedTvEpisodes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllWatchedTvEpisodes = `-- name: DeleteAllWatchedTvEpisodes :many
DELETE FROM watched_tv_episodes WHERE tmdb_id = $1 AND user_id = $2
RETURNING id, user_id, tmdb_id, season_number, episode_number, watched_at, created_at, updated_at
`

type DeleteAllWatchedTvEpisodesParams struct {
	TmdbID int32 `json:"tmdb_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteAllWatchedTvEpisodes(ctx context.Context, arg DeleteAllWatchedTvEpisodesParams) ([]WatchedTvEpisode, error) {
	rows, err := q.db.Query(ctx, deleteAllWatchedTvEpisodes, arg.TmdbID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchedTvEpisode
	for rows.Next() {
		var i WatchedTvEpisode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TmdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.WatchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAllWatchedTvSeasons = `-- name: DeleteAllWatchedTvSeasons :many
DELETE FROM watched_tv_seasons WHERE tmdb_id = $1 AND user_id = $2
RETURNING id, user_id, tmdb_id, season_number, total_episodes, created_at, updated_at, status
`

type DeleteAllWatchedTvSeasonsParams struct {
	TmdbID int32 `json:"tmdb_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteAllWatchedTvSeasons(ctx context.Context, arg DeleteAllWatchedTvSeasonsParams) ([]WatchedTvSeason, error) {
	rows, err := q.db.Query(ctx, deleteAllWatchedTvSeasons, arg.TmdbID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchedTvSeason
	for rows.Next() {
		var i WatchedTvSeason
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TmdbID,
			&i.SeasonNumber,
			&i.TotalEpisodes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteWatchedTv = `-- name: DeleteWatchedTv :one
DELETE FROM watched_tv_shows WHERE tmdb_id = $1 AND user_id = $2
RETURNING id, user_id, tmdb_id, status, total_seasons, total_episodes, created_at, updated_at, progress
`

type DeleteWatchedTvParams struct {
	TmdbID int32 `json:"tmdb_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteWatchedTv(ctx context.Context, arg DeleteWatchedTvParams) (WatchedTvShow, error) {
	row := q.db.QueryRow(ctx, deleteWatchedTv, arg.TmdbID, arg.UserID)
	var i WatchedTvShow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.Status,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Progress,
	)
	return i, err
}

const deleteWatchedTvEpisode = `-- name: DeleteWatchedTvEpisode :one
DELETE FROM watched_tv_episodes WHERE tmdb_id = $1 AND user_id = $2 AND season_number = $3 AND episode_number = $4
RETURNING id, user_id, tmdb_id, season_number, episode_number, watched_at, created_at, updated_at
`

type DeleteWatchedTvEpisodeParams struct {
	TmdbID        int32 `json:"tmdb_id"`
	UserID        int32 `json:"user_id"`
	SeasonNumber  int32 `json:"season_number"`
	EpisodeNumber int32 `json:"episode_number"`
}

func (q *Queries) DeleteWatchedTvEpisode(ctx context.Context, arg DeleteWatchedTvEpisodeParams) (WatchedTvEpisode, error) {
	row := q.db.QueryRow(ctx, deleteWatchedTvEpisode,
		arg.TmdbID,
		arg.UserID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
	)
	var i WatchedTvEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.WatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWatchedTvSeason = `-- name: DeleteWatchedTvSeason :one
DELETE FROM watched_tv_seasons WHERE tmdb_id = $1 AND user_id = $2 AND season_number = $3
RETURNING id, user_id, tmdb_id, season_number, total_episodes, created_at, updated_at, status
`

type DeleteWatchedTvSeasonParams struct {
	TmdbID       int32 `json:"tmdb_id"`
	UserID       int32 `json:"user_id"`
	SeasonNumber int32 `json:"season_number"`
}

func (q *Queries) DeleteWatchedTvSeason(ctx context.Context, arg DeleteWatchedTvSeasonParams) (WatchedTvSeason, error) {
	row := q.db.QueryRow(ctx, deleteWatchedTvSeason, arg.TmdbID, arg.UserID, arg.SeasonNumber)
	var i WatchedTvSeason
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getNextEpisode = `-- name: GetNextEpisode :one
with all_possible_episodes as (
  select
    wts.season_number,
    generate_series(1, wts.total_episodes) as episode_number
  from watched_tv_seasons wts
  where wts.user_id = $1 and wts.tmdb_id = $2
),
watched_episodes as (
  select
    wte.season_number,
    wte.episode_number
  from watched_tv_episodes wte
  where wte.user_id = $1 and wte.tmdb_id = $2
),
missing_episodes as (
  select
    ape.season_number,
    ape.episode_number
  from all_possible_episodes ape
  left join watched_episodes we on
    ape.season_number = we.season_number
    and ape.episode_number = we.episode_number
  where we.episode_number is null
),
next_season as (
  select
    ws.season_number,
    1 as episode_number
  from generate_series(1, (
    select total_seasons from watched_tv_shows wts
    where wts.user_id = $1 and wts.tmdb_id = $2
  )) as ws(season_number)
  where not exists (
    select 1
    from watched_tv_seasons wts
    where wts.user_id = $1 and wts.tmdb_id = $2
      and wts.season_number = ws.season_number
  )
),
next_episode as (
  select
    season_number,
    episode_number
  from missing_episodes
  union all
  select
    season_number,
    episode_number
  from next_season
)
select
  season_number,
  episode_number
from next_episode
order by season_number, episode_number
limit 1
`

type GetNextEpisodeParams struct {
	UserID int32 `json:"user_id"`
	TmdbID int32 `json:"tmdb_id"`
}

type GetNextEpisodeRow struct {
	SeasonNumber  int32   `json:"season_number"`
	EpisodeNumber float32 `json:"episode_number"`
}

func (q *Queries) GetNextEpisode(ctx context.Context, arg GetNextEpisodeParams) (GetNextEpisodeRow, error) {
	row := q.db.QueryRow(ctx, getNextEpisode, arg.UserID, arg.TmdbID)
	var i GetNextEpisodeRow
	err := row.Scan(&i.SeasonNumber, &i.EpisodeNumber)
	return i, err
}

const getWatchedTv = `-- name: GetWatchedTv :one
SELECT id, user_id, tmdb_id, status, total_seasons, total_episodes, created_at, updated_at, progress FROM watched_tv_shows WHERE tmdb_id = $1 AND user_id = $2 AND status in ('watched', 'in progress')
`

type GetWatchedTvParams struct {
	TmdbID int32 `json:"tmdb_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetWatchedTv(ctx context.Context, arg GetWatchedTvParams) (WatchedTvShow, error) {
	row := q.db.QueryRow(ctx, getWatchedTv, arg.TmdbID, arg.UserID)
	var i WatchedTvShow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.Status,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Progress,
	)
	return i, err
}

const getWatchedTvEpisode = `-- name: GetWatchedTvEpisode :one
SELECT id, user_id, tmdb_id, season_number, episode_number, watched_at, created_at, updated_at FROM watched_tv_episodes WHERE tmdb_id = $1 AND user_id = $2 AND season_number = $3 AND episode_number = $4 AND watched_at IS NOT NULL
`

type GetWatchedTvEpisodeParams struct {
	TmdbID        int32 `json:"tmdb_id"`
	UserID        int32 `json:"user_id"`
	SeasonNumber  int32 `json:"season_number"`
	EpisodeNumber int32 `json:"episode_number"`
}

func (q *Queries) GetWatchedTvEpisode(ctx context.Context, arg GetWatchedTvEpisodeParams) (WatchedTvEpisode, error) {
	row := q.db.QueryRow(ctx, getWatchedTvEpisode,
		arg.TmdbID,
		arg.UserID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
	)
	var i WatchedTvEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.WatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWatchedTvSeason = `-- name: GetWatchedTvSeason :one
SELECT id, user_id, tmdb_id, season_number, total_episodes, created_at, updated_at, status FROM watched_tv_seasons WHERE tmdb_id = $1 AND user_id = $2 AND season_number = $3 AND status in ('watched', 'in progress')
`

type GetWatchedTvSeasonParams struct {
	TmdbID       int32 `json:"tmdb_id"`
	UserID       int32 `json:"user_id"`
	SeasonNumber int32 `json:"season_number"`
}

func (q *Queries) GetWatchedTvSeason(ctx context.Context, arg GetWatchedTvSeasonParams) (WatchedTvSeason, error) {
	row := q.db.QueryRow(ctx, getWatchedTvSeason, arg.TmdbID, arg.UserID, arg.SeasonNumber)
	var i WatchedTvSeason
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const insertWatchedTv = `-- name: InsertWatchedTv :one
INSERT INTO watched_tv_shows
(tmdb_id, user_id, total_seasons, total_episodes)
VALUES($1, $2, $3, $4) ON CONFLICT (tmdb_id, user_id) DO NOTHING
RETURNING id, user_id, tmdb_id, status, total_seasons, total_episodes, created_at, updated_at, progress
`

type InsertWatchedTvParams struct {
	TmdbID        int32 `json:"tmdb_id"`
	UserID        int32 `json:"user_id"`
	TotalSeasons  int32 `json:"total_seasons"`
	TotalEpisodes int32 `json:"total_episodes"`
}

func (q *Queries) InsertWatchedTv(ctx context.Context, arg InsertWatchedTvParams) (WatchedTvShow, error) {
	row := q.db.QueryRow(ctx, insertWatchedTv,
		arg.TmdbID,
		arg.UserID,
		arg.TotalSeasons,
		arg.TotalEpisodes,
	)
	var i WatchedTvShow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.Status,
		&i.TotalSeasons,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Progress,
	)
	return i, err
}

const insertWatchedTvEpisode = `-- name: InsertWatchedTvEpisode :one
INSERT INTO watched_tv_episodes
(tmdb_id, user_id, season_number, episode_number, watched_at)
VALUES($1, $2, $3, $4, $5) ON CONFLICT (tmdb_id, user_id, season_number, episode_number) DO NOTHING
RETURNING id, user_id, tmdb_id, season_number, episode_number, watched_at, created_at, updated_at
`

type InsertWatchedTvEpisodeParams struct {
	TmdbID        int32              `json:"tmdb_id"`
	UserID        int32              `json:"user_id"`
	SeasonNumber  int32              `json:"season_number"`
	EpisodeNumber int32              `json:"episode_number"`
	WatchedAt     pgtype.Timestamptz `json:"watched_at"`
}

func (q *Queries) InsertWatchedTvEpisode(ctx context.Context, arg InsertWatchedTvEpisodeParams) (WatchedTvEpisode, error) {
	row := q.db.QueryRow(ctx, insertWatchedTvEpisode,
		arg.TmdbID,
		arg.UserID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.WatchedAt,
	)
	var i WatchedTvEpisode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.WatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertWatchedTvSeason = `-- name: InsertWatchedTvSeason :one
INSERT INTO watched_tv_seasons
(tmdb_id, user_id, season_number, total_episodes)
VALUES($1, $2, $3, $4) ON CONFLICT (tmdb_id, user_id, season_number) DO NOTHING
RETURNING id, user_id, tmdb_id, season_number, total_episodes, created_at, updated_at, status
`

type InsertWatchedTvSeasonParams struct {
	TmdbID        int32 `json:"tmdb_id"`
	UserID        int32 `json:"user_id"`
	SeasonNumber  int32 `json:"season_number"`
	TotalEpisodes int32 `json:"total_episodes"`
}

func (q *Queries) InsertWatchedTvSeason(ctx context.Context, arg InsertWatchedTvSeasonParams) (WatchedTvSeason, error) {
	row := q.db.QueryRow(ctx, insertWatchedTvSeason,
		arg.TmdbID,
		arg.UserID,
		arg.SeasonNumber,
		arg.TotalEpisodes,
	)
	var i WatchedTvSeason
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TmdbID,
		&i.SeasonNumber,
		&i.TotalEpisodes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const listWatchedTv = `-- name: ListWatchedTv :many
SELECT id, user_id, tmdb_id, status, total_seasons, total_episodes, created_at, updated_at, progress FROM watched_tv_shows WHERE user_id = $1 AND
status in ('watched', 'in progress')
`

func (q *Queries) ListWatchedTv(ctx context.Context, userID int32) ([]WatchedTvShow, error) {
	rows, err := q.db.Query(ctx, listWatchedTv, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchedTvShow
	for rows.Next() {
		var i WatchedTvShow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TmdbID,
			&i.Status,
			&i.TotalSeasons,
			&i.TotalEpisodes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Progress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchedTvEpisodes = `-- name: ListWatchedTvEpisodes :many
SELECT id, user_id, tmdb_id, season_number, episode_number, watched_at, created_at, updated_at FROM watched_tv_episodes WHERE tmdb_id = $1 AND user_id = $2 AND season_number = $3 AND watched_at IS NOT NULL
`

type ListWatchedTvEpisodesParams struct {
	TmdbID       int32 `json:"tmdb_id"`
	UserID       int32 `json:"user_id"`
	SeasonNumber int32 `json:"season_number"`
}

func (q *Queries) ListWatchedTvEpisodes(ctx context.Context, arg ListWatchedTvEpisodesParams) ([]WatchedTvEpisode, error) {
	rows, err := q.db.Query(ctx, listWatchedTvEpisodes, arg.TmdbID, arg.UserID, arg.SeasonNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchedTvEpisode
	for rows.Next() {
		var i WatchedTvEpisode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TmdbID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.WatchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWatchedTvSeasons = `-- name: ListWatchedTvSeasons :many
SELECT id, user_id, tmdb_id, season_number, total_episodes, created_at, updated_at, status FROM watched_tv_seasons WHERE tmdb_id = $1 AND user_id = $2 AND status in ('watched', 'in progress')
`

type ListWatchedTvSeasonsParams struct {
	TmdbID int32 `json:"tmdb_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) ListWatchedTvSeasons(ctx context.Context, arg ListWatchedTvSeasonsParams) ([]WatchedTvSeason, error) {
	rows, err := q.db.Query(ctx, listWatchedTvSeasons, arg.TmdbID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchedTvSeason
	for rows.Next() {
		var i WatchedTvSeason
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TmdbID,
			&i.SeasonNumber,
			&i.TotalEpisodes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
